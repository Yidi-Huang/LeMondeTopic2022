<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="./css/sous-style1.css" />
        <link href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet" />
        <title>bao1</title>
    </head>
    <body>
        <header class="header">
            <a href="#" class="logo">Projet Encadré: <h1 class="title">Boite À Outils 1</h1></a>
            <nav class="navbar">
                <a href="./index.html" class="item" style="--i: 1">Accueil</a>
                <a href="./BAO1.html" class="active item" style="--i:  2">BAO1</a>
                <a href="./BAO2.html" class="item" style="--i:  3">BAO2</a>
                <a href="./BAO3.html" class="item" style="--i:  4">BAO3</a>
                <a href="./BAO41.html" class="item" style="--i:  5">BAO4</a>
            </nav>
        </header>
        <section id="wrapper">
            <header>
                <div class="inner">
                    <h2>Boîte à Outils 1</h2>
                    <p>Lecture de fichiers RSS, Extraction (récursive) de texte et métadonnées</p>
                </div>
            </header>
            <!-- Content -->
            <div class="wrapper">
                <div class="inner">
                    <h3 class="major">Idée principale</h3>
                    <p>RSS (« Really Simple Syndication ») est un des applications de XML, qui est
                        généré automatiquement et régulièrement pendant la mise à jour d’un site
                        web. Il comporte les titres et les résumés des dernières infos, qui nous
                        permet de suivre les nouvelles d’un site. Ici, on utilise l’ensemble des
                        fils RSS de l’année, recueilli par M. Fleury, en tant que notre corpus de
                        travail.</p>
                    <p>La première méthode serait d'utiliser le module `etree` `re` `feedparser` en
                        Python pour extraire les titres et les descriptions du fichier xml. Tout
                        d'abord, `etree` est plus simple au module re, car il s'adapte à la
                        structure de XML avec les fonctions root() et tree(). Il est possible de
                        détecter les titres et les descriptions du item en respectant le chemin et
                        la forme root.findall(".//item"). En plus, en utilisant le module, les
                        crochet à la fin et les caractères au début (CDATA) ne seront pas affichés
                        dans le résultat.</p>
                    <p>Après un aperçu sur les strctures de ces trois modules en classe, nous avons
                        décidé d'utiliser le module `feedparser` comme notre méthode d'extraction.
                        Ce dernier s'adapte précisément à la structure de XML, ce qui évite beaucoup
                        de problèmes liés à des balises. En plus, le module est moins complexe à
                        appliquer par rapport à deux autres.</p>
                    <p>Néanmoins, pour que le script puisse traiter tous les fichiers en lançant le
                        script une seule fois, on derait aussi utiliser l’idée de récursivité, qui
                        nous permet de parcourir le corpus arborescent. Dans ce cas, nous avons
                        essayé deux modules utiles `pathlib` `os`.</p>
                    <p>En employant `argparser`, on pourrait simplement parvenir à notre obejctif en
                        déterminant les arguments lors du lancement du script en question.</p>
                    <h3 class="major">Script</h3>
                    <p>3 rubriques sont traitées par notre script : "une", "international",
                        "politique". Voici le script et les résultats obtenus.</p>
                    <ul class="actions">
                        <li>
                            <a href="./fichiers/scripts/extraire_many.py" class="button primary"
                                >Script</a>
                        </li>
                        <li>
                            <a href="#" class="button">Résultat UNE</a>
                        </li>
                        <li>
                            <a href="#" class="button">Résultat INTERNATIONAL</a>
                        </li>
                        <li>
                            <a href="#" class="button">Résultat POLITIQUE</a>
                        </li>
                    </ul>
                    <pre><code>#!/usr/bin/env python3
from typing import Optional, List, Dict
import xml.etree.ElementTree as ET
import argparse
import re
from pathlib import Path
from datetime import date  # pour renvoyer dans le bon ordre chronologique
from tqdm import tqdm

from extraire_un import extraire_td, extraire_a
from datastructures import Corpus, Article, Token
from export_xml import write_xml
from export_json import write_json
from export_pickle import write_pickle

MONTHS = ["Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"]

DAYS = [f"{x:02}" for x in range(1, 32)]

# Définir le dictionnaire de correspondance entre les catégories et les noms de fichiers XML
categories_dict = {
    "une": "0,2-3208,1-0,0",
    "international": "0,2-3210,1-0,0",
    "europe": "0,2-3214,1-0,0",
    "societe": "0,2-3224,1-0,0",
    "idees": "0,2-3232,1-0,0",
    "economie": "0,2-3234,1-0,0",
    "actualite-medias": "0,2-3236,1-0,0",
    "sport": "0,2-3242,1-0,0",
    "planete": "0,2-3244,1-0,0",
    "culture": "0,2-3246,1-0,0",
    "livres": "0,2-3260,1-0,0",
    "cinema": "0,2-3476,1-0,0",
    "voyage": "0,2-3546,1-0,0",
    "technologies": "0,2-651865,1-0,0",
    "politique": "0,57-0,64-823353,0",
    "sciences": "env_sciences"
}
new_dict = {valeur: cle for cle, valeur in categories_dict.items()}


def categorie_of_filename(filename: str) -> Optional[str]:
    for nom, code in categories_dict.items():
        if code in filename:
            return nom
    return None


def convert_month(m: str) -> int:
    return MONTHS.index(m) + 1


def parcours_dossier(corpus_dir: Path, categories: Optional[List[str]] = None,
                        start_date: Optional[date] = None, end_date: Optional[date] = None):
    if categories is not None and len(categories) > 0:
        categories = [categories_dict[c.lower()] for c in categories]
    else:
        categories = categories_dict.values()

    for month_dir in corpus_dir.iterdir():
        if not month_dir.is_dir():
            continue
        m = convert_month(month_dir.name)
        for day_dir in month_dir.iterdir():
            if not day_dir.is_dir():
                continue
            d = date.fromisoformat(f"2022-{m:02}-{day_dir.name}")
            if (start_date is not None and d < start_date) or (end_date is not None and d > end_date):
                continue
            for hour_dir in day_dir.iterdir():
                if not hour_dir.is_dir():
                    continue
                if re.match(r"\d{2}-\d{2}-\d{2}", hour_dir.name):
                    for xml_file in hour_dir.iterdir():
                        if xml_file.name.endswith(".xml") and any([xml_file.name.startswith(c) for c in categories]):
                            # yield(xml_file.name, extraire_td(xml_file.as_posix()))
                            c = categorie_of_filename(xml_file.name)
                            yield xml_file, d.isoformat(), c


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-s", help="start date (iso format)", default="2022-01-01")
    parser.add_argument("-e", help="end date (iso format)",
                        default="2023-01-01")
    parser.add_argument(
        "-o", help="output file (stdout si non spécifié)", required=True)
    parser.add_argument(
        "-f", help="format de sortie (xml par défault)", choices = ['xml','json','pickle'], default="xml",required = True)
    parser.add_argument(
        "-p", help="parser à utiliser (spacy par défault)",choices = ['spacy','stanza','trankit'], required = True, default="spacy")
    parser.add_argument("corpus_dir", help="la racine du dossier")
    parser.add_argument("categories", nargs="*", help="catégories à retenir")
    args = parser.parse_args()
    corpus = Corpus(categories=args.categories, begin=args.s,
                    end=args.e, chemin=Path(args.corpus_dir), articles=[])
    for xml_file, d, c in tqdm(parcours_dossier(Path(args.corpus_dir), args.categories, date.fromisoformat(args.s), date.fromisoformat(args.e))):
        for article in extraire_a(xml_file, d, c):
            corpus.articles.append(article)
    if args.p == "spacy" or args.p == None:
        import analyse_sp as analyse
    elif args.p == "stanza":
        import analyse_st as analyse
    elif args.p == "trankit":
        import analyse_tk as analyse
    for a in tqdm(corpus.articles):
        parser = analyse.create_parser()
        analyse.analyse_article(parser, a)
    if args.o is None:
        for title, description in extraire_td(args.corpus_dir):
            print(title)
            print(description)
    if args.o is not None:
        if args.f == "xml":
            write_xml(corpus, args.o)
        elif args.f == "json":
            write_json(corpus, args.o)
        elif args.f == "pickle":
            write_pickle(corpus, args.o)
        else:
            print("format non supporté")


if __name__ == "__main__":
    main()
                        
# exemple d'utilisation: python3 extraire_deux.py -s 2022-01-01 -e 2022-01-31 -o corpus.xml /home/.../corpus une international                                  
                    </code></pre>
                    <section class="features">
                        <article>
                            <h3 class="major">boîte à outils 2</h3>
                            <p>Enrichissement des données</p>
                            <a href="./BAO2.html" class="special">Savoir plus</a>
                        </article>
                        <article>
                            <h3 class="major">boîte à outils 3</h3>
                            <p>Récupération automatique des patrons</p>
                            <a href="./BAO3.html" class="special">Savoir plus</a>
                        </article>
                    </section>
                </div>
            </div>
        </section>
        <footer id="footer">
            <ul class="copyright">
                <li>&copy; ppe2_chz</li>
                <li>Xinhao, Weixuan, Yidi</li>
            </ul>
        </footer>
        <!--scripts-->
        <script src="javascript/jquery.min.js"></script>
        <script src="javascript/jquery.scrollex.min.js"></script>
        <script src="javascript/browser.min.js"></script>
        <script src="javascript/breakpoints.min.js"></script>
        <script src="javascript/util.js"></script>
    </body>
</html>

